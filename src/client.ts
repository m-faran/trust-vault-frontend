/* eslint-disable */
/**
 * This file was automatically generated by @algorandfoundation/algokit-client-generator.
 * DO NOT MODIFY IT BY HAND.
 * requires: @algorandfoundation/algokit-utils: ^7
 */
import { type AlgorandClient } from '@algorandfoundation/algokit-utils/types/algorand-client'
import { ABIReturn, AppReturn, SendAppTransactionResult } from '@algorandfoundation/algokit-utils/types/app'
import { Arc56Contract, getArc56ReturnValue, getABIStructFromABITuple } from '@algorandfoundation/algokit-utils/types/app-arc56'
import {
  AppClient as _AppClient,
  AppClientMethodCallParams,
  AppClientParams,
  AppClientBareCallParams,
  CallOnComplete,
  AppClientCompilationParams,
  ResolveAppClientByCreatorAndName,
  ResolveAppClientByNetwork,
  CloneAppClientParams,
} from '@algorandfoundation/algokit-utils/types/app-client'
import { AppFactory as _AppFactory, AppFactoryAppClientParams, AppFactoryResolveAppClientByCreatorAndNameParams, AppFactoryDeployParams, AppFactoryParams, CreateSchema } from '@algorandfoundation/algokit-utils/types/app-factory'
import { TransactionComposer, AppCallMethodCall, AppMethodCallTransactionArgument, SimulateOptions, RawSimulateOptions, SkipSignaturesSimulateOptions } from '@algorandfoundation/algokit-utils/types/composer'
import { SendParams, SendSingleTransactionResult, SendAtomicTransactionComposerResults } from '@algorandfoundation/algokit-utils/types/transaction'
import { Address, encodeAddress, modelsv2, OnApplicationComplete, Transaction, TransactionSigner } from 'algosdk'

export const APP_SPEC: Arc56Contract = {"name":"TrustVault","structs":{},"methods":[{"name":"opt_in","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["OptIn"]},"readonly":false,"desc":"--- THIS IS THE OPT-IN METHOD ---\nAllows a user to opt-in to this contract. This creates their local state and initializes it.\nA user's wallet must send an ApplicationOptInTransaction to call this specific method.","events":[],"recommendations":{}},{"name":"setup_vault","args":[{"type":"address","name":"heir","desc":"The trusted address (Heir) that will inherit funds after inactivity period"},{"type":"uint64","name":"heartbeat_interval","desc":"Time in seconds before funds can be claimed (3 months to 1 year)"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Set up a vault with an heir address.\nVault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.","events":[],"recommendations":{}},{"name":"deposit_funds","args":[{"type":"pay","name":"payment","desc":"Payment transaction from the transaction group (must be gtxn[i] where i is the payment transaction index)"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Deposit funds into an existing vault.\nVault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.\nPayment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0","events":[],"recommendations":{}},{"name":"update_heir","args":[{"type":"address","name":"new_heir","desc":"New trusted address (Heir) to inherit funds"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update the heir address for an existing vault.\nOnly the Vault User (vault owner) can update their heir.","events":[],"recommendations":{}},{"name":"update_heartbeat_interval","args":[{"type":"uint64","name":"new_interval","desc":"New heartbeat interval in seconds (3 months to 1 year)"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update the heartbeat interval for an existing vault.\nOnly the Vault User can update their heartbeat interval.","events":[],"recommendations":{}},{"name":"heartbeat","args":[],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Update the last heartbeat timestamp to indicate Vault User activity.\nThis resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.","events":[],"recommendations":{}},{"name":"claim_funds","args":[{"type":"address","name":"vault_owner","desc":"The Vault User account whose vault funds should be claimed"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.\nOnly the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.","events":[],"recommendations":{}},{"name":"withdraw_funds","args":[{"type":"uint64","name":"amount","desc":"Amount to withdraw from the vault"}],"returns":{"type":"void"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Allow the Vault User to withdraw funds from their vault.\nOnly the Vault User (vault owner) can withdraw their funds.","events":[],"recommendations":{}},{"name":"get_vault_info","args":[{"type":"address","name":"vault_owner","desc":"The Vault User account to query vault information for"}],"returns":{"type":"(address,uint64,uint64,uint64)","desc":"Tuple of (heir_address, last_heartbeat_timestamp, heartbeat_interval, vault_balance)"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Get vault information for a Vault User.\nCan be called by anyone to query vault information.","events":[],"recommendations":{}},{"name":"get_total_vaults","args":[],"returns":{"type":"uint64","desc":"Total number of active vaults"},"actions":{"create":[],"call":["NoOp"]},"readonly":false,"desc":"Get the total number of active vaults.","events":[],"recommendations":{}}],"arcs":[22,28],"desc":"\n    Trust Vault - A decentralized vault system for fund inheritance.\n    \n    Roles:\n    - Vault User: Locks funds in a vault, sets up heir, sends heartbeats (must opt-in)\n    - Heir: Inherits funds after vault user's inactivity period (no opt-in required)\n    \n    Storage Strategy:\n    - Local State: Vault configuration (heir, interval, last heartbeat) - per vault owner\n    - Box Storage: Vault balances and vault owners tracking - no opt-in required\n    - Global State: Application-level counters (total vaults)\n    ","networks":{},"state":{"schema":{"global":{"ints":1,"bytes":0},"local":{"ints":2,"bytes":1}},"keys":{"global":{"total_vaults":{"keyType":"AVMString","valueType":"AVMUint64","key":"dG90YWxfdmF1bHRz"}},"local":{"heir":{"keyType":"AVMString","valueType":"address","key":"aGVpcg=="},"heartbeat_interval":{"keyType":"AVMString","valueType":"AVMUint64","key":"aW50ZXJ2YWw="},"last_heartbeat":{"keyType":"AVMString","valueType":"AVMUint64","key":"bGFzdF9oYg=="}},"box":{}},"maps":{"global":{},"local":{},"box":{"vault_balances":{"keyType":"address","valueType":"uint64","prefix":"YmFsYW5jZV8="},"vault_owners":{"keyType":"address","valueType":"uint64","prefix":"b3duZXJf"}}}},"bareActions":{"create":["NoOp"],"call":[]},"sourceInfo":{"approval":{"sourceInfo":[{"pc":[590],"errorMessage":"Amount must be greater than zero"},{"pc":[487],"errorMessage":"Heartbeat data missing"},{"pc":[237,412],"errorMessage":"Heartbeat interval too long (max 1 year)"},{"pc":[232,407],"errorMessage":"Heartbeat interval too short (min 3 months)"},{"pc":[522],"errorMessage":"Inactivity period not yet reached"},{"pc":[626],"errorMessage":"Insufficient balance in vault"},{"pc":[493],"errorMessage":"Interval data missing"},{"pc":[524],"errorMessage":"No funds to transfer"},{"pc":[94],"errorMessage":"OnCompletion must be NoOp"},{"pc":[187],"errorMessage":"OnCompletion must be NoOp && can only call when creating"},{"pc":[176],"errorMessage":"OnCompletion must be OptIn && can only call when not creating"},{"pc":[513],"errorMessage":"Only the designated heir can claim funds"},{"pc":[348],"errorMessage":"Payment amount must be greater than zero"},{"pc":[335],"errorMessage":"Payment must be from vault owner"},{"pc":[343],"errorMessage":"Payment must be to contract address"},{"pc":[254],"errorMessage":"Vault already exists for this user"},{"pc":[503,617],"errorMessage":"Vault balance not found"},{"pc":[429,452,481,607,675],"errorMessage":"Vault configuration not found"},{"pc":[382,422,445,600],"errorMessage":"Vault does not exist"},{"pc":[475,667],"errorMessage":"Vault does not exist for this user"},{"pc":[327],"errorMessage":"Vault does not exist. Call setup_vault first"},{"pc":[244,387],"errorMessage":"Vault owner cannot be their own heir"},{"pc":[691],"errorMessage":"check self.heartbeat_interval exists for account"},{"pc":[683],"errorMessage":"check self.last_heartbeat exists for account"},{"pc":[356,705],"errorMessage":"check self.vault_balances entry exists"},{"pc":[218,372,466,659],"errorMessage":"invalid number of bytes for arc4.static_array<arc4.uint8, 32>"},{"pc":[226,401,587],"errorMessage":"invalid number of bytes for arc4.uint64"},{"pc":[317],"errorMessage":"transaction type is pay"}],"pcOffsetMethod":"none"},"clear":{"sourceInfo":[],"pcOffsetMethod":"none"}},"source":{"approval":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuYXBwcm92YWxfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIGludGNibG9jayAxIDAgMzIgOCA3Nzc2MDAwIDMxNTM2MDAwCiAgICBieXRlY2Jsb2NrIDB4NmY3NzZlNjU3MjVmICJoZWlyIiAibGFzdF9oYiIgImludGVydmFsIiAidG90YWxfdmF1bHRzIiAweDYyNjE2YzYxNmU2MzY1NWYgMHgxNTFmN2M3NQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjkKICAgIC8vIGNsYXNzIFRydXN0VmF1bHQoQVJDNENvbnRyYWN0KToKICAgIHR4biBOdW1BcHBBcmdzCiAgICBieiBtYWluX19fYWxnb3B5X2RlZmF1bHRfY3JlYXRlQDIwCiAgICBwdXNoYnl0ZXMgMHgzMGM2ZDU4YSAvLyBtZXRob2QgIm9wdF9pbigpdm9pZCIKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDAKICAgIG1hdGNoIG1haW5fb3B0X2luX3JvdXRlQDUKCm1haW5fc3dpdGNoX2Nhc2VfbmV4dEA2OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjkKICAgIC8vIGNsYXNzIFRydXN0VmF1bHQoQVJDNENvbnRyYWN0KToKICAgIHR4biBPbkNvbXBsZXRpb24KICAgICEKICAgIGFzc2VydCAvLyBPbkNvbXBsZXRpb24gbXVzdCBiZSBOb09wCiAgICB0eG4gQXBwbGljYXRpb25JRAogICAgYXNzZXJ0CiAgICBwdXNoYnl0ZXNzIDB4OGQ4Y2EzY2EgMHhmZGM2OTVjMiAweGU5ZTZkZmEyIDB4NTg4YzczMDkgMHg0ODkzNDM1ZCAweGIyMDViOWM2IDB4YmE5MGFiNTQgMHg1NTIyNjIzYiAweGEzZmM3YWNkIC8vIG1ldGhvZCAic2V0dXBfdmF1bHQoYWRkcmVzcyx1aW50NjQpdm9pZCIsIG1ldGhvZCAiZGVwb3NpdF9mdW5kcyhwYXkpdm9pZCIsIG1ldGhvZCAidXBkYXRlX2hlaXIoYWRkcmVzcyl2b2lkIiwgbWV0aG9kICJ1cGRhdGVfaGVhcnRiZWF0X2ludGVydmFsKHVpbnQ2NCl2b2lkIiwgbWV0aG9kICJoZWFydGJlYXQoKXZvaWQiLCBtZXRob2QgImNsYWltX2Z1bmRzKGFkZHJlc3Mpdm9pZCIsIG1ldGhvZCAid2l0aGRyYXdfZnVuZHModWludDY0KXZvaWQiLCBtZXRob2QgImdldF92YXVsdF9pbmZvKGFkZHJlc3MpKGFkZHJlc3MsdWludDY0LHVpbnQ2NCx1aW50NjQpIiwgbWV0aG9kICJnZXRfdG90YWxfdmF1bHRzKCl1aW50NjQiCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAwCiAgICBtYXRjaCBzZXR1cF92YXVsdCBkZXBvc2l0X2Z1bmRzIHVwZGF0ZV9oZWlyIHVwZGF0ZV9oZWFydGJlYXRfaW50ZXJ2YWwgaGVhcnRiZWF0IGNsYWltX2Z1bmRzIHdpdGhkcmF3X2Z1bmRzIGdldF92YXVsdF9pbmZvIGdldF90b3RhbF92YXVsdHMKICAgIGVycgoKbWFpbl9vcHRfaW5fcm91dGVANToKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTo0MwogICAgLy8gQGFiaW1ldGhvZChhbGxvd19hY3Rpb25zPVsiT3B0SW4iXSkKICAgIHR4biBPbkNvbXBsZXRpb24KICAgIGludGNfMCAvLyBPcHRJbgogICAgPT0KICAgIHR4biBBcHBsaWNhdGlvbklECiAgICAmJgogICAgYXNzZXJ0IC8vIE9uQ29tcGxldGlvbiBtdXN0IGJlIE9wdEluICYmIGNhbiBvbmx5IGNhbGwgd2hlbiBub3QgY3JlYXRpbmcKICAgIGIgb3B0X2luCgptYWluX19fYWxnb3B5X2RlZmF1bHRfY3JlYXRlQDIwOgogICAgdHhuIE9uQ29tcGxldGlvbgogICAgIQogICAgdHhuIEFwcGxpY2F0aW9uSUQKICAgICEKICAgICYmCiAgICBhc3NlcnQgLy8gT25Db21wbGV0aW9uIG11c3QgYmUgTm9PcCAmJiBjYW4gb25seSBjYWxsIHdoZW4gY3JlYXRpbmcKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMudHJ1c3RfdmF1bHQuY29udHJhY3QuVHJ1c3RWYXVsdC5vcHRfaW5bcm91dGluZ10oKSAtPiB2b2lkOgpvcHRfaW46CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6NTQtNTUKICAgIC8vICMgVHhuLnNlbmRlciBpcyB0aGUgYWNjb3VudCB0aGF0IGlzIG9wdGluZyBpbgogICAgLy8gc2VuZGVyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjYwLTYyCiAgICAvLyAjIFdlIHNldCB0aGUgaGVpciB0byB0aGUgc2VuZGVyJ3Mgb3duIGFkZHJlc3MgYXMgYQogICAgLy8gIyBzYWZlIGRlZmF1bHQuIFRoZXkgbXVzdCBjYWxsIGFub3RoZXIgbWV0aG9kIHRvIHNldCB0aGUgcmVhbCBoZWlyLgogICAgLy8gc2VsZi5oZWlyW3NlbmRlcl0gPSBzZW5kZXIKICAgIGR1cAogICAgYnl0ZWNfMSAvLyAiaGVpciIKICAgIGRpZyAyCiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6NjQtNjUKICAgIC8vICMgU2V0IHRoZSBpbml0aWFsIGhlYXJ0YmVhdCB0byB0aGUgY3VycmVudCB0aW1lCiAgICAvLyBzZWxmLmxhc3RfaGVhcnRiZWF0W3NlbmRlcl0gPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgZGlnIDEKICAgIGJ5dGVjXzIgLy8gImxhc3RfaGIiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTo2Ny02OAogICAgLy8gIyBTZXQgdGhlIGluaXRpYWwgaGVhcnRiZWF0IGludGVydmFsCiAgICAvLyBzZWxmLmhlYXJ0YmVhdF9pbnRlcnZhbFtzZW5kZXJdID0gR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAKICAgIGJ5dGVjXzMgLy8gImludGVydmFsIgogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjQzCiAgICAvLyBAYWJpbWV0aG9kKGFsbG93X2FjdGlvbnM9WyJPcHRJbiJdKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50cnVzdF92YXVsdC5jb250cmFjdC5UcnVzdFZhdWx0LnNldHVwX3ZhdWx0W3JvdXRpbmddKCkgLT4gdm9pZDoKc2V0dXBfdmF1bHQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6NzAKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMiAvLyAzMgogICAgPT0KICAgIGFzc2VydCAvLyBpbnZhbGlkIG51bWJlciBvZiBieXRlcyBmb3IgYXJjNC5zdGF0aWNfYXJyYXk8YXJjNC51aW50OCwgMzI+CiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAyCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6ODUtODYKICAgIC8vICMgVmFsaWRhdGUgaGVhcnRiZWF0IGludGVydmFsIGlzIHdpdGhpbiBhbGxvd2VkIHJhbmdlICgzIG1vbnRocyB0byAxIHllYXIpCiAgICAvLyBhc3NlcnQgaGVhcnRiZWF0X2ludGVydmFsID49IFVJbnQ2NChNSU5fSEVBUlRCRUFUX0lOVEVSVkFMX1NFQ09ORFMpLCAiSGVhcnRiZWF0IGludGVydmFsIHRvbyBzaG9ydCAobWluIDMgbW9udGhzKSIKICAgIGR1cAogICAgaW50YyA0IC8vIDc3NzYwMDAKICAgID49CiAgICBhc3NlcnQgLy8gSGVhcnRiZWF0IGludGVydmFsIHRvbyBzaG9ydCAobWluIDMgbW9udGhzKQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5Ojg3CiAgICAvLyBhc3NlcnQgaGVhcnRiZWF0X2ludGVydmFsIDw9IFVJbnQ2NChNQVhfSEVBUlRCRUFUX0lOVEVSVkFMX1NFQ09ORFMpLCAiSGVhcnRiZWF0IGludGVydmFsIHRvbyBsb25nIChtYXggMSB5ZWFyKSIKICAgIGR1cAogICAgaW50YyA1IC8vIDMxNTM2MDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIEhlYXJ0YmVhdCBpbnRlcnZhbCB0b28gbG9uZyAobWF4IDEgeWVhcikKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTo4OQogICAgLy8gdmF1bHRfb3duZXIgPSBUeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6OTEtOTIKICAgIC8vICMgQ3JpdGljYWw6IFZhdWx0IG93bmVyIGNhbm5vdCBiZSB0aGVpciBvd24gaGVpcgogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyICE9IGhlaXIsICJWYXVsdCBvd25lciBjYW5ub3QgYmUgdGhlaXIgb3duIGhlaXIiCiAgICBkdXAKICAgIGRpZyAzCiAgICAhPQogICAgYXNzZXJ0IC8vIFZhdWx0IG93bmVyIGNhbm5vdCBiZSB0aGVpciBvd24gaGVpcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5Ojk0LTk1CiAgICAvLyAjIFZlcmlmeSB2YXVsdCBkb2Vzbid0IGFscmVhZHkgZXhpc3QgYnkgY2hlY2tpbmcgdmF1bHRfb3duZXJzIEJveE1hcAogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIG5vdCBpbiBzZWxmLnZhdWx0X293bmVycywgIlZhdWx0IGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHVzZXIiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgIQogICAgYXNzZXJ0IC8vIFZhdWx0IGFscmVhZHkgZXhpc3RzIGZvciB0aGlzIHVzZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTo5Ny05OQogICAgLy8gIyBTdG9yZSB2YXVsdCBjb25maWd1cmF0aW9uIGluIGxvY2FsIHN0YXRlICh2YXVsdCBvd25lcidzIGRhdGEpCiAgICAvLyAjIFRoaXMgcmVxdWlyZXMgdGhlIHZhdWx0IG93bmVyIHRvIGhhdmUgb3B0ZWQgaW4gdG8gdGhlIGFwcGxpY2F0aW9uCiAgICAvLyBzZWxmLmhlaXJbdmF1bHRfb3duZXJdID0gaGVpcgogICAgZGlnIDEKICAgIGJ5dGVjXzEgLy8gImhlaXIiCiAgICB1bmNvdmVyIDUKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMDAKICAgIC8vIHNlbGYuaGVhcnRiZWF0X2ludGVydmFsW3ZhdWx0X293bmVyXSA9IGhlYXJ0YmVhdF9pbnRlcnZhbAogICAgZGlnIDEKICAgIGJ5dGVjXzMgLy8gImludGVydmFsIgogICAgdW5jb3ZlciA0CiAgICBhcHBfbG9jYWxfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTAxCiAgICAvLyBzZWxmLmxhc3RfaGVhcnRiZWF0W3ZhdWx0X293bmVyXSA9IEdsb2JhbC5sYXRlc3RfdGltZXN0YW1wCiAgICBnbG9iYWwgTGF0ZXN0VGltZXN0YW1wCiAgICBkaWcgMgogICAgYnl0ZWNfMiAvLyAibGFzdF9oYiIKICAgIHVuY292ZXIgMgogICAgYXBwX2xvY2FsX3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjEwMy0xMDQKICAgIC8vICMgTWFyayB0aGlzIGFjY291bnQgYXMgYSB2YXVsdCBvd25lciBpbiBib3ggc3RvcmFnZQogICAgLy8gc2VsZi52YXVsdF9vd25lcnNbdmF1bHRfb3duZXJdID0gVUludDY0KDEpICAjIDEgPSB2YXVsdCBleGlzdHMKICAgIGludGNfMCAvLyAxCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTA2LTEwNwogICAgLy8gIyBJbml0aWFsaXplIHZhdWx0IGJhbGFuY2UgaW4gYm94IHN0b3JhZ2UgKHN0YXJ0IHdpdGggMCwgdXNlciBkZXBvc2l0cyBzZXBhcmF0ZWx5KQogICAgLy8gc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0gPSBVSW50NjQoMCkKICAgIGJ5dGVjIDUgLy8gMHg2MjYxNmM2MTZlNjM2NTVmCiAgICBzd2FwCiAgICBjb25jYXQKICAgIGludGNfMSAvLyAwCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTA5LTExMAogICAgLy8gIyBVcGRhdGUgZ2xvYmFsIGNvdW50ZXIKICAgIC8vIGN1cnJlbnRfdG90YWwsIGV4aXN0cyA9IHNlbGYudG90YWxfdmF1bHRzLm1heWJlKCkKICAgIGludGNfMSAvLyAwCiAgICBieXRlYyA0IC8vICJ0b3RhbF92YXVsdHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjExMQogICAgLy8gaWYgZXhpc3RzOgogICAgYnogc2V0dXBfdmF1bHRfZWxzZV9ib2R5QDMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMTIKICAgIC8vIHNlbGYudG90YWxfdmF1bHRzLnZhbHVlID0gY3VycmVudF90b3RhbCArIFVJbnQ2NCgxKQogICAgZHVwCiAgICBpbnRjXzAgLy8gMQogICAgKwogICAgYnl0ZWMgNCAvLyAidG90YWxfdmF1bHRzIgogICAgc3dhcAogICAgYXBwX2dsb2JhbF9wdXQKCnNldHVwX3ZhdWx0X2FmdGVyX2lmX2Vsc2VANDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTo3MAogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgpzZXR1cF92YXVsdF9lbHNlX2JvZHlAMzoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMTQKICAgIC8vIHNlbGYudG90YWxfdmF1bHRzLnZhbHVlID0gVUludDY0KDEpCiAgICBieXRlYyA0IC8vICJ0b3RhbF92YXVsdHMiCiAgICBpbnRjXzAgLy8gMQogICAgYXBwX2dsb2JhbF9wdXQKICAgIGIgc2V0dXBfdmF1bHRfYWZ0ZXJfaWZfZWxzZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLnRydXN0X3ZhdWx0LmNvbnRyYWN0LlRydXN0VmF1bHQuZGVwb3NpdF9mdW5kc1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmRlcG9zaXRfZnVuZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTE2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4biBHcm91cEluZGV4CiAgICBpbnRjXzAgLy8gMQogICAgLQogICAgZHVwCiAgICBndHhucyBUeXBlRW51bQogICAgaW50Y18wIC8vIHBheQogICAgPT0KICAgIGFzc2VydCAvLyB0cmFuc2FjdGlvbiB0eXBlIGlzIHBheQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjEzMQogICAgLy8gdmF1bHRfb3duZXIgPSBUeG4uc2VuZGVyCiAgICB0eG4gU2VuZGVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTMzLTEzNAogICAgLy8gIyBWZXJpZnkgdmF1bHQgZXhpc3RzIGJ5IGNoZWNraW5nIHZhdWx0X293bmVycyBCb3hNYXAKICAgIC8vIGFzc2VydCB2YXVsdF9vd25lciBpbiBzZWxmLnZhdWx0X293bmVycywgIlZhdWx0IGRvZXMgbm90IGV4aXN0LiBDYWxsIHNldHVwX3ZhdWx0IGZpcnN0IgogICAgYnl0ZWNfMCAvLyAweDZmNzc2ZTY1NzI1ZgogICAgZGlnIDEKICAgIGNvbmNhdAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gVmF1bHQgZG9lcyBub3QgZXhpc3QuIENhbGwgc2V0dXBfdmF1bHQgZmlyc3QKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMzYtMTM3CiAgICAvLyAjIFZlcmlmeSBwYXltZW50IHRyYW5zYWN0aW9uIHByb3BlcnRpZXMKICAgIC8vIGFzc2VydCBwYXltZW50LnNlbmRlciA9PSB2YXVsdF9vd25lciwgIlBheW1lbnQgbXVzdCBiZSBmcm9tIHZhdWx0IG93bmVyIgogICAgZGlnIDEKICAgIGd0eG5zIFNlbmRlcgogICAgZGlnIDEKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBtdXN0IGJlIGZyb20gdmF1bHQgb3duZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMzgKICAgIC8vIGFzc2VydCBwYXltZW50LnJlY2VpdmVyID09IEdsb2JhbC5jdXJyZW50X2FwcGxpY2F0aW9uX2FkZHJlc3MsICJQYXltZW50IG11c3QgYmUgdG8gY29udHJhY3QgYWRkcmVzcyIKICAgIGRpZyAxCiAgICBndHhucyBSZWNlaXZlcgogICAgZ2xvYmFsIEN1cnJlbnRBcHBsaWNhdGlvbkFkZHJlc3MKICAgID09CiAgICBhc3NlcnQgLy8gUGF5bWVudCBtdXN0IGJlIHRvIGNvbnRyYWN0IGFkZHJlc3MKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxMzkKICAgIC8vIGFzc2VydCBwYXltZW50LmFtb3VudCA+IFVJbnQ2NCgwKSwgIlBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8iCiAgICBzd2FwCiAgICBndHhucyBBbW91bnQKICAgIGR1cAogICAgYXNzZXJ0IC8vIFBheW1lbnQgYW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNDEtMTQyCiAgICAvLyAjIFVwZGF0ZSB2YXVsdCBiYWxhbmNlIGluIGJveCBzdG9yYWdlCiAgICAvLyBjdXJyZW50X2JhbGFuY2UgPSBzZWxmLnZhdWx0X2JhbGFuY2VzW3ZhdWx0X293bmVyXQogICAgYnl0ZWMgNSAvLyAweDYyNjE2YzYxNmU2MzY1NWYKICAgIHVuY292ZXIgMgogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9nZXQKICAgIGFzc2VydCAvLyBjaGVjayBzZWxmLnZhdWx0X2JhbGFuY2VzIGVudHJ5IGV4aXN0cwogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE0MwogICAgLy8gc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0gPSBjdXJyZW50X2JhbGFuY2UgKyBwYXltZW50LmFtb3VudAogICAgdW5jb3ZlciAyCiAgICArCiAgICBpdG9iCiAgICBib3hfcHV0CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTE2CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCgovLyBzbWFydF9jb250cmFjdHMudHJ1c3RfdmF1bHQuY29udHJhY3QuVHJ1c3RWYXVsdC51cGRhdGVfaGVpcltyb3V0aW5nXSgpIC0+IHZvaWQ6CnVwZGF0ZV9oZWlyOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE0NQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18yIC8vIDMyCiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnN0YXRpY19hcnJheTxhcmM0LnVpbnQ4LCAzMj4KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNTQKICAgIC8vIHZhdWx0X293bmVyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE1Ni0xNTcKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cwogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYudmF1bHRfb3duZXJzLCAiVmF1bHQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE1OS0xNjAKICAgIC8vICMgQ3JpdGljYWw6IFZhdWx0IG93bmVyIGNhbm5vdCBiZSB0aGVpciBvd24gaGVpcgogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyICE9IG5ld19oZWlyLCAiVmF1bHQgb3duZXIgY2Fubm90IGJlIHRoZWlyIG93biBoZWlyIgogICAgZHVwCiAgICBkaWcgMgogICAgIT0KICAgIGFzc2VydCAvLyBWYXVsdCBvd25lciBjYW5ub3QgYmUgdGhlaXIgb3duIGhlaXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNjItMTYzCiAgICAvLyAjIFVwZGF0ZSBoZWlyIGluIGxvY2FsIHN0YXRlCiAgICAvLyBzZWxmLmhlaXJbdmF1bHRfb3duZXJdID0gbmV3X2hlaXIKICAgIGJ5dGVjXzEgLy8gImhlaXIiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNDUKICAgIC8vIEBhYmltZXRob2QoKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50cnVzdF92YXVsdC5jb250cmFjdC5UcnVzdFZhdWx0LnVwZGF0ZV9oZWFydGJlYXRfaW50ZXJ2YWxbcm91dGluZ10oKSAtPiB2b2lkOgp1cGRhdGVfaGVhcnRiZWF0X2ludGVydmFsOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE2NQogICAgLy8gQGFiaW1ldGhvZCgpCiAgICB0eG5hIEFwcGxpY2F0aW9uQXJncyAxCiAgICBkdXAKICAgIGxlbgogICAgaW50Y18zIC8vIDgKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQudWludDY0CiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTc0LTE3NQogICAgLy8gIyBWYWxpZGF0ZSBoZWFydGJlYXQgaW50ZXJ2YWwgaXMgd2l0aGluIGFsbG93ZWQgcmFuZ2UgKDMgbW9udGhzIHRvIDEgeWVhcikKICAgIC8vIGFzc2VydCBuZXdfaW50ZXJ2YWwgPj0gVUludDY0KE1JTl9IRUFSVEJFQVRfSU5URVJWQUxfU0VDT05EUyksICJIZWFydGJlYXQgaW50ZXJ2YWwgdG9vIHNob3J0IChtaW4gMyBtb250aHMpIgogICAgZHVwCiAgICBpbnRjIDQgLy8gNzc3NjAwMAogICAgPj0KICAgIGFzc2VydCAvLyBIZWFydGJlYXQgaW50ZXJ2YWwgdG9vIHNob3J0IChtaW4gMyBtb250aHMpCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTc2CiAgICAvLyBhc3NlcnQgbmV3X2ludGVydmFsIDw9IFVJbnQ2NChNQVhfSEVBUlRCRUFUX0lOVEVSVkFMX1NFQ09ORFMpLCAiSGVhcnRiZWF0IGludGVydmFsIHRvbyBsb25nIChtYXggMSB5ZWFyKSIKICAgIGR1cAogICAgaW50YyA1IC8vIDMxNTM2MDAwCiAgICA8PQogICAgYXNzZXJ0IC8vIEhlYXJ0YmVhdCBpbnRlcnZhbCB0b28gbG9uZyAobWF4IDEgeWVhcikKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNzgKICAgIC8vIHZhdWx0X293bmVyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE4MC0xODEKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cwogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYudmF1bHRfb3duZXJzLCAiVmF1bHQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE4MgogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYuaGVhcnRiZWF0X2ludGVydmFsLCAiVmF1bHQgY29uZmlndXJhdGlvbiBub3QgZm91bmQiCiAgICBkdXAKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18zIC8vICJpbnRlcnZhbCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFZhdWx0IGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MTg0LTE4NQogICAgLy8gIyBVcGRhdGUgaW50ZXJ2YWwgaW4gbG9jYWwgc3RhdGUKICAgIC8vIHNlbGYuaGVhcnRiZWF0X2ludGVydmFsW3ZhdWx0X293bmVyXSA9IG5ld19pbnRlcnZhbAogICAgYnl0ZWNfMyAvLyAiaW50ZXJ2YWwiCiAgICB1bmNvdmVyIDIKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxNjUKICAgIC8vIEBhYmltZXRob2QoKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50cnVzdF92YXVsdC5jb250cmFjdC5UcnVzdFZhdWx0LmhlYXJ0YmVhdFtyb3V0aW5nXSgpIC0+IHZvaWQ6CmhlYXJ0YmVhdDoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxOTQKICAgIC8vIHZhdWx0X293bmVyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE5Ni0xOTcKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cwogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYudmF1bHRfb3duZXJzLCAiVmF1bHQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjE5OAogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYubGFzdF9oZWFydGJlYXQsICJWYXVsdCBjb25maWd1cmF0aW9uIG5vdCBmb3VuZCIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxhc3RfaGIiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBjb25maWd1cmF0aW9uIG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIwMC0yMDEKICAgIC8vICMgVXBkYXRlIGxhc3QgaGVhcnRiZWF0IHRpbWVzdGFtcCBpbiBsb2NhbCBzdGF0ZQogICAgLy8gc2VsZi5sYXN0X2hlYXJ0YmVhdFt2YXVsdF9vd25lcl0gPSBHbG9iYWwubGF0ZXN0X3RpbWVzdGFtcAogICAgYnl0ZWNfMiAvLyAibGFzdF9oYiIKICAgIGdsb2JhbCBMYXRlc3RUaW1lc3RhbXAKICAgIGFwcF9sb2NhbF9wdXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToxODcKICAgIC8vIEBhYmltZXRob2QoKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50cnVzdF92YXVsdC5jb250cmFjdC5UcnVzdFZhdWx0LmNsYWltX2Z1bmRzW3JvdXRpbmddKCkgLT4gdm9pZDoKY2xhaW1fZnVuZHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjAzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIxMy0yMTQKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cyAoY2hlY2sgdmF1bHRfb3duZXJzIEJveE1hcCBmaXJzdCkKICAgIC8vIGFzc2VydCB2YXVsdF9vd25lciBpbiBzZWxmLnZhdWx0X293bmVycywgIlZhdWx0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIHVzZXIiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBkdXAKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFZhdWx0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIHVzZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyMTYtMjE3CiAgICAvLyAjIFZlcmlmeSB2YXVsdCBjb25maWd1cmF0aW9uIGV4aXN0cyBpbiBsb2NhbCBzdGF0ZQogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYuaGVpciwgIlZhdWx0IGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kIgogICAgZGlnIDEKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18xIC8vICJoZWlyIgogICAgYXBwX2xvY2FsX2dldF9leAogICAgYXNzZXJ0IC8vIFZhdWx0IGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjE4CiAgICAvLyBhc3NlcnQgdmF1bHRfb3duZXIgaW4gc2VsZi5sYXN0X2hlYXJ0YmVhdCwgIkhlYXJ0YmVhdCBkYXRhIG1pc3NpbmciCiAgICBkaWcgMgogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxhc3RfaGIiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBhc3NlcnQgLy8gSGVhcnRiZWF0IGRhdGEgbWlzc2luZwogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIxOQogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYuaGVhcnRiZWF0X2ludGVydmFsLCAiSW50ZXJ2YWwgZGF0YSBtaXNzaW5nIgogICAgZGlnIDMKICAgIGludGNfMSAvLyAwCiAgICBieXRlY18zIC8vICJpbnRlcnZhbCIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGFzc2VydCAvLyBJbnRlcnZhbCBkYXRhIG1pc3NpbmcKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyMjYtMjI3CiAgICAvLyAjIEdldCB2YXVsdCBiYWxhbmNlIGZyb20gYm94IHN0b3JhZ2UKICAgIC8vIGFzc2VydCB2YXVsdF9vd25lciBpbiBzZWxmLnZhdWx0X2JhbGFuY2VzLCAiVmF1bHQgYmFsYW5jZSBub3QgZm91bmQiCiAgICBieXRlYyA1IC8vIDB4NjI2MTZjNjE2ZTYzNjU1ZgogICAgZGlnIDUKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBiYWxhbmNlIG5vdCBmb3VuZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIyOAogICAgLy8gdmF1bHRfYmFsYW5jZSA9IHNlbGYudmF1bHRfYmFsYW5jZXNbdmF1bHRfb3duZXJdCiAgICBkdXAKICAgIGJveF9nZXQKICAgIHBvcAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIzMC0yMzEKICAgIC8vICMgVmVyaWZ5IGNhbGxlciBpcyB0aGUgZGVzaWduYXRlZCBIZWlyCiAgICAvLyBhc3NlcnQgVHhuLnNlbmRlciA9PSBoZWlyLCAiT25seSB0aGUgZGVzaWduYXRlZCBoZWlyIGNhbiBjbGFpbSBmdW5kcyIKICAgIHR4biBTZW5kZXIKICAgIGRpZyA1CiAgICA9PQogICAgYXNzZXJ0IC8vIE9ubHkgdGhlIGRlc2lnbmF0ZWQgaGVpciBjYW4gY2xhaW0gZnVuZHMKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyMzMtMjM0CiAgICAvLyAjIENoZWNrIGlmIFZhdWx0IFVzZXIgaGFzIGJlZW4gaW5hY3RpdmUgYmV5b25kIHRoZSBoZWFydGJlYXQgaW50ZXJ2YWwKICAgIC8vIHRpbWVfc2luY2VfaGVhcnRiZWF0ID0gR2xvYmFsLmxhdGVzdF90aW1lc3RhbXAgLSBsYXN0X2hlYXJ0YmVhdAogICAgZ2xvYmFsIExhdGVzdFRpbWVzdGFtcAogICAgdW5jb3ZlciA0CiAgICAtCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjM1CiAgICAvLyBhc3NlcnQgdGltZV9zaW5jZV9oZWFydGJlYXQgPj0gaGVhcnRiZWF0X2ludGVydmFsLCAiSW5hY3Rpdml0eSBwZXJpb2Qgbm90IHlldCByZWFjaGVkIgogICAgdW5jb3ZlciAzCiAgICA+PQogICAgYXNzZXJ0IC8vIEluYWN0aXZpdHkgcGVyaW9kIG5vdCB5ZXQgcmVhY2hlZAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIzNy0yMzgKICAgIC8vICMgVmVyaWZ5IHRoZXJlIGFyZSBmdW5kcyB0byB0cmFuc2ZlcgogICAgLy8gYXNzZXJ0IHZhdWx0X2JhbGFuY2UgPiBVSW50NjQoMCksICJObyBmdW5kcyB0byB0cmFuc2ZlciIKICAgIGR1cAogICAgYXNzZXJ0IC8vIE5vIGZ1bmRzIHRvIHRyYW5zZmVyCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjQwLTI0NgogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyB0byBIZWlyIHZpYSBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHNlbmRlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlY2VpdmVyPWhlaXIsCiAgICAvLyAgICAgYW1vdW50PXZhdWx0X2JhbGFuY2UsCiAgICAvLyAgICAgZmVlPTAsICAjIEZlZSBwYWlkIGJ5IG91dGVyIHRyYW5zYWN0aW9uCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjQyCiAgICAvLyBzZW5kZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICBzd2FwCiAgICBpdHhuX2ZpZWxkIEFtb3VudAogICAgdW5jb3ZlciAyCiAgICBpdHhuX2ZpZWxkIFJlY2VpdmVyCiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI0MC0yNDEKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgdG8gSGVpciB2aWEgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIGludGNfMCAvLyBwYXkKICAgIGl0eG5fZmllbGQgVHlwZUVudW0KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyNDUKICAgIC8vIGZlZT0wLCAgIyBGZWUgcGFpZCBieSBvdXRlciB0cmFuc2FjdGlvbgogICAgaW50Y18xIC8vIDAKICAgIGl0eG5fZmllbGQgRmVlCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjQwLTI0NgogICAgLy8gIyBUcmFuc2ZlciBmdW5kcyB0byBIZWlyIHZpYSBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHNlbmRlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlY2VpdmVyPWhlaXIsCiAgICAvLyAgICAgYW1vdW50PXZhdWx0X2JhbGFuY2UsCiAgICAvLyAgICAgZmVlPTAsICAjIEZlZSBwYWlkIGJ5IG91dGVyIHRyYW5zYWN0aW9uCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX3N1Ym1pdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI0OC0yNTAKICAgIC8vICMgQ2xlYXIgdmF1bHQgZGF0YSBhZnRlciBzdWNjZXNzZnVsIHRyYW5zZmVyCiAgICAvLyAjIENsZWFyIGxvY2FsIHN0YXRlICh2YXVsdCBvd25lciBjYW4gb3B0LW91dCBzZXBhcmF0ZWx5IGlmIGRlc2lyZWQpCiAgICAvLyBkZWwgc2VsZi5oZWlyW3ZhdWx0X293bmVyXQogICAgZGlnIDIKICAgIGJ5dGVjXzEgLy8gImhlaXIiCiAgICBhcHBfbG9jYWxfZGVsCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjUxCiAgICAvLyBkZWwgc2VsZi5sYXN0X2hlYXJ0YmVhdFt2YXVsdF9vd25lcl0KICAgIGRpZyAyCiAgICBieXRlY18yIC8vICJsYXN0X2hiIgogICAgYXBwX2xvY2FsX2RlbAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI1MgogICAgLy8gZGVsIHNlbGYuaGVhcnRiZWF0X2ludGVydmFsW3ZhdWx0X293bmVyXQogICAgdW5jb3ZlciAyCiAgICBieXRlY18zIC8vICJpbnRlcnZhbCIKICAgIGFwcF9sb2NhbF9kZWwKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyNTQtMjU1CiAgICAvLyAjIENsZWFyIGJveCBzdG9yYWdlCiAgICAvLyBkZWwgc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0KICAgIGJveF9kZWwKICAgIHBvcAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI1NgogICAgLy8gZGVsIHNlbGYudmF1bHRfb3duZXJzW3ZhdWx0X293bmVyXQogICAgYm94X2RlbAogICAgcG9wCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjU4LTI1OQogICAgLy8gIyBVcGRhdGUgZ2xvYmFsIGNvdW50ZXIKICAgIC8vIGN1cnJlbnRfdG90YWwsIGV4aXN0cyA9IHNlbGYudG90YWxfdmF1bHRzLm1heWJlKCkKICAgIGludGNfMSAvLyAwCiAgICBieXRlYyA0IC8vICJ0b3RhbF92YXVsdHMiCiAgICBhcHBfZ2xvYmFsX2dldF9leAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI2MAogICAgLy8gaWYgZXhpc3RzIGFuZCBjdXJyZW50X3RvdGFsID4gVUludDY0KDApOgogICAgYnogY2xhaW1fZnVuZHNfYWZ0ZXJfaWZfZWxzZUA1CiAgICBkdXAKICAgIGJ6IGNsYWltX2Z1bmRzX2FmdGVyX2lmX2Vsc2VANQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI2MQogICAgLy8gc2VsZi50b3RhbF92YXVsdHMudmFsdWUgPSBjdXJyZW50X3RvdGFsIC0gVUludDY0KDEpCiAgICBkdXAKICAgIGludGNfMCAvLyAxCiAgICAtCiAgICBieXRlYyA0IC8vICJ0b3RhbF92YXVsdHMiCiAgICBzd2FwCiAgICBhcHBfZ2xvYmFsX3B1dAoKY2xhaW1fZnVuZHNfYWZ0ZXJfaWZfZWxzZUA1OgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjIwMwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBpbnRjXzAgLy8gMQogICAgcmV0dXJuCgoKLy8gc21hcnRfY29udHJhY3RzLnRydXN0X3ZhdWx0LmNvbnRyYWN0LlRydXN0VmF1bHQud2l0aGRyYXdfZnVuZHNbcm91dGluZ10oKSAtPiB2b2lkOgp3aXRoZHJhd19mdW5kczoKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyNjMKICAgIC8vIEBhYmltZXRob2QoKQogICAgdHhuYSBBcHBsaWNhdGlvbkFyZ3MgMQogICAgZHVwCiAgICBsZW4KICAgIGludGNfMyAvLyA4CiAgICA9PQogICAgYXNzZXJ0IC8vIGludmFsaWQgbnVtYmVyIG9mIGJ5dGVzIGZvciBhcmM0LnVpbnQ2NAogICAgYnRvaQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI3MgogICAgLy8gYXNzZXJ0IGFtb3VudCA+IFVJbnQ2NCgwKSwgIkFtb3VudCBtdXN0IGJlIGdyZWF0ZXIgdGhhbiB6ZXJvIgogICAgZHVwCiAgICBhc3NlcnQgLy8gQW1vdW50IG11c3QgYmUgZ3JlYXRlciB0aGFuIHplcm8KICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyNzQKICAgIC8vIHZhdWx0X293bmVyID0gVHhuLnNlbmRlcgogICAgdHhuIFNlbmRlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI3Ni0yNzcKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cwogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYudmF1bHRfb3duZXJzLCAiVmF1bHQgZG9lcyBub3QgZXhpc3QiCiAgICBieXRlY18wIC8vIDB4NmY3NzZlNjU3MjVmCiAgICBkaWcgMQogICAgY29uY2F0CiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGFzc2VydCAvLyBWYXVsdCBkb2VzIG5vdCBleGlzdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI3OAogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYuaGVpciwgIlZhdWx0IGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kIgogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMSAvLyAiaGVpciIKICAgIGFwcF9sb2NhbF9nZXRfZXgKICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFZhdWx0IGNvbmZpZ3VyYXRpb24gbm90IGZvdW5kCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6Mjc5CiAgICAvLyBhc3NlcnQgdmF1bHRfb3duZXIgaW4gc2VsZi52YXVsdF9iYWxhbmNlcywgIlZhdWx0IGJhbGFuY2Ugbm90IGZvdW5kIgogICAgYnl0ZWMgNSAvLyAweDYyNjE2YzYxNmU2MzY1NWYKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGR1cAogICAgYm94X2xlbgogICAgYnVyeSAxCiAgICBhc3NlcnQgLy8gVmF1bHQgYmFsYW5jZSBub3QgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyODEtMjgyCiAgICAvLyAjIEdldCBjdXJyZW50IGJhbGFuY2UgZnJvbSBib3ggc3RvcmFnZQogICAgLy8gY3VycmVudF9iYWxhbmNlID0gc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0KICAgIGR1cAogICAgYm94X2dldAogICAgcG9wCiAgICBidG9pCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6Mjg0LTI4NQogICAgLy8gIyBWZXJpZnkgc3VmZmljaWVudCBiYWxhbmNlCiAgICAvLyBhc3NlcnQgY3VycmVudF9iYWxhbmNlID49IGFtb3VudCwgIkluc3VmZmljaWVudCBiYWxhbmNlIGluIHZhdWx0IgogICAgZHVwCiAgICBkaWcgNAogICAgPj0KICAgIGFzc2VydCAvLyBJbnN1ZmZpY2llbnQgYmFsYW5jZSBpbiB2YXVsdAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI4Ny0yODgKICAgIC8vICMgVXBkYXRlIHZhdWx0IGJhbGFuY2UgaW4gYm94IHN0b3JhZ2UKICAgIC8vIG5ld19iYWxhbmNlID0gY3VycmVudF9iYWxhbmNlIC0gYW1vdW50CiAgICBkaWcgMwogICAgLQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI4OQogICAgLy8gc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0gPSBuZXdfYmFsYW5jZQogICAgaXRvYgogICAgYm94X3B1dAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI5MS0yOTcKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgYmFjayB0byBWYXVsdCBVc2VyIHZpYSBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5QYXltZW50KAogICAgLy8gICAgIHNlbmRlcj1HbG9iYWwuY3VycmVudF9hcHBsaWNhdGlvbl9hZGRyZXNzLAogICAgLy8gICAgIHJlY2VpdmVyPXZhdWx0X293bmVyLAogICAgLy8gICAgIGFtb3VudD1hbW91bnQsCiAgICAvLyAgICAgZmVlPTAsICAjIEZlZSBwYWlkIGJ5IG91dGVyIHRyYW5zYWN0aW9uCiAgICAvLyApLnN1Ym1pdCgpCiAgICBpdHhuX2JlZ2luCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MjkzCiAgICAvLyBzZW5kZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIGdsb2JhbCBDdXJyZW50QXBwbGljYXRpb25BZGRyZXNzCiAgICB1bmNvdmVyIDIKICAgIGl0eG5fZmllbGQgQW1vdW50CiAgICBpdHhuX2ZpZWxkIFNlbmRlcgogICAgaXR4bl9maWVsZCBSZWNlaXZlcgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI5MS0yOTIKICAgIC8vICMgVHJhbnNmZXIgZnVuZHMgYmFjayB0byBWYXVsdCBVc2VyIHZpYSBpbm5lciB0cmFuc2FjdGlvbgogICAgLy8gaXR4bi5QYXltZW50KAogICAgaW50Y18wIC8vIHBheQogICAgaXR4bl9maWVsZCBUeXBlRW51bQogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjI5NgogICAgLy8gZmVlPTAsICAjIEZlZSBwYWlkIGJ5IG91dGVyIHRyYW5zYWN0aW9uCiAgICBpbnRjXzEgLy8gMAogICAgaXR4bl9maWVsZCBGZWUKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyOTEtMjk3CiAgICAvLyAjIFRyYW5zZmVyIGZ1bmRzIGJhY2sgdG8gVmF1bHQgVXNlciB2aWEgaW5uZXIgdHJhbnNhY3Rpb24KICAgIC8vIGl0eG4uUGF5bWVudCgKICAgIC8vICAgICBzZW5kZXI9R2xvYmFsLmN1cnJlbnRfYXBwbGljYXRpb25fYWRkcmVzcywKICAgIC8vICAgICByZWNlaXZlcj12YXVsdF9vd25lciwKICAgIC8vICAgICBhbW91bnQ9YW1vdW50LAogICAgLy8gICAgIGZlZT0wLCAgIyBGZWUgcGFpZCBieSBvdXRlciB0cmFuc2FjdGlvbgogICAgLy8gKS5zdWJtaXQoKQogICAgaXR4bl9zdWJtaXQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weToyNjMKICAgIC8vIEBhYmltZXRob2QoKQogICAgaW50Y18wIC8vIDEKICAgIHJldHVybgoKCi8vIHNtYXJ0X2NvbnRyYWN0cy50cnVzdF92YXVsdC5jb250cmFjdC5UcnVzdFZhdWx0LmdldF92YXVsdF9pbmZvW3JvdXRpbmddKCkgLT4gdm9pZDoKZ2V0X3ZhdWx0X2luZm86CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6Mjk5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIHR4bmEgQXBwbGljYXRpb25BcmdzIDEKICAgIGR1cAogICAgbGVuCiAgICBpbnRjXzIgLy8gMzIKICAgID09CiAgICBhc3NlcnQgLy8gaW52YWxpZCBudW1iZXIgb2YgYnl0ZXMgZm9yIGFyYzQuc3RhdGljX2FycmF5PGFyYzQudWludDgsIDMyPgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjMxMS0zMTIKICAgIC8vICMgVmVyaWZ5IHZhdWx0IGV4aXN0cwogICAgLy8gYXNzZXJ0IHZhdWx0X293bmVyIGluIHNlbGYudmF1bHRfb3duZXJzLCAiVmF1bHQgZG9lcyBub3QgZXhpc3QgZm9yIHRoaXMgdXNlciIKICAgIGJ5dGVjXzAgLy8gMHg2Zjc3NmU2NTcyNWYKICAgIGRpZyAxCiAgICBjb25jYXQKICAgIGJveF9sZW4KICAgIGJ1cnkgMQogICAgYXNzZXJ0IC8vIFZhdWx0IGRvZXMgbm90IGV4aXN0IGZvciB0aGlzIHVzZXIKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTozMTMKICAgIC8vIGFzc2VydCB2YXVsdF9vd25lciBpbiBzZWxmLmhlaXIsICJWYXVsdCBjb25maWd1cmF0aW9uIG5vdCBmb3VuZCIKICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzEgLy8gImhlaXIiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gVmF1bHQgY29uZmlndXJhdGlvbiBub3QgZm91bmQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTozMTcKICAgIC8vIGxhc3RfaGVhcnRiZWF0ID0gc2VsZi5sYXN0X2hlYXJ0YmVhdFt2YXVsdF9vd25lcl0KICAgIGR1cAogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjXzIgLy8gImxhc3RfaGIiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5sYXN0X2hlYXJ0YmVhdCBleGlzdHMgZm9yIGFjY291bnQKICAgIC8vIHNtYXJ0X2NvbnRyYWN0cy90cnVzdF92YXVsdC9jb250cmFjdC5weTozMTgKICAgIC8vIGhlYXJ0YmVhdF9pbnRlcnZhbCA9IHNlbGYuaGVhcnRiZWF0X2ludGVydmFsW3ZhdWx0X293bmVyXQogICAgZHVwCiAgICBpbnRjXzEgLy8gMAogICAgYnl0ZWNfMyAvLyAiaW50ZXJ2YWwiCiAgICBhcHBfbG9jYWxfZ2V0X2V4CiAgICBzd2FwCiAgICBjb3ZlciAyCiAgICBhc3NlcnQgLy8gY2hlY2sgc2VsZi5oZWFydGJlYXRfaW50ZXJ2YWwgZXhpc3RzIGZvciBhY2NvdW50CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzIwLTMyMQogICAgLy8gIyBHZXQgYmFsYW5jZSBmcm9tIGJveCBzdG9yYWdlCiAgICAvLyBpZiB2YXVsdF9vd25lciBpbiBzZWxmLnZhdWx0X2JhbGFuY2VzOgogICAgYnl0ZWMgNSAvLyAweDYyNjE2YzYxNmU2MzY1NWYKICAgIHN3YXAKICAgIGNvbmNhdAogICAgZHVwCiAgICBib3hfbGVuCiAgICBidXJ5IDEKICAgIGJ6IGdldF92YXVsdF9pbmZvX2Vsc2VfYm9keUAzCiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzIyCiAgICAvLyB2YXVsdF9iYWxhbmNlID0gc2VsZi52YXVsdF9iYWxhbmNlc1t2YXVsdF9vd25lcl0KICAgIGR1cAogICAgYm94X2dldAogICAgYXNzZXJ0IC8vIGNoZWNrIHNlbGYudmF1bHRfYmFsYW5jZXMgZW50cnkgZXhpc3RzCiAgICBidG9pCgpnZXRfdmF1bHRfaW5mb19hZnRlcl9pZl9lbHNlQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6Mjk5CiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGRpZyAzCiAgICBpdG9iCiAgICBkaWcgNQogICAgc3dhcAogICAgY29uY2F0CiAgICBkaWcgMwogICAgaXRvYgogICAgY29uY2F0CiAgICBzd2FwCiAgICBpdG9iCiAgICBjb25jYXQKICAgIGJ5dGVjIDYgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmdldF92YXVsdF9pbmZvX2Vsc2VfYm9keUAzOgogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjMyNAogICAgLy8gdmF1bHRfYmFsYW5jZSA9IFVJbnQ2NCgwKQogICAgaW50Y18xIC8vIDAKICAgIGIgZ2V0X3ZhdWx0X2luZm9fYWZ0ZXJfaWZfZWxzZUA0CgoKLy8gc21hcnRfY29udHJhY3RzLnRydXN0X3ZhdWx0LmNvbnRyYWN0LlRydXN0VmF1bHQuZ2V0X3RvdGFsX3ZhdWx0c1tyb3V0aW5nXSgpIC0+IHZvaWQ6CmdldF90b3RhbF92YXVsdHM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzQxCiAgICAvLyB0b3RhbCwgZXhpc3RzID0gc2VsZi50b3RhbF92YXVsdHMubWF5YmUoKQogICAgaW50Y18xIC8vIDAKICAgIGJ5dGVjIDQgLy8gInRvdGFsX3ZhdWx0cyIKICAgIGFwcF9nbG9iYWxfZ2V0X2V4CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzQyCiAgICAvLyBpZiBleGlzdHM6CiAgICBieiBnZXRfdG90YWxfdmF1bHRzX2Vsc2VfYm9keUAzCiAgICBkdXAKCmdldF90b3RhbF92YXVsdHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMudHJ1c3RfdmF1bHQuY29udHJhY3QuVHJ1c3RWYXVsdC5nZXRfdG90YWxfdmF1bHRzQDQ6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzMzCiAgICAvLyBAYWJpbWV0aG9kKCkKICAgIGl0b2IKICAgIGJ5dGVjIDYgLy8gMHgxNTFmN2M3NQogICAgc3dhcAogICAgY29uY2F0CiAgICBsb2cKICAgIGludGNfMCAvLyAxCiAgICByZXR1cm4KCmdldF90b3RhbF92YXVsdHNfZWxzZV9ib2R5QDM6CiAgICAvLyBzbWFydF9jb250cmFjdHMvdHJ1c3RfdmF1bHQvY29udHJhY3QucHk6MzQ1CiAgICAvLyByZXR1cm4gVUludDY0KDApCiAgICBpbnRjXzEgLy8gMAogICAgLy8gc21hcnRfY29udHJhY3RzL3RydXN0X3ZhdWx0L2NvbnRyYWN0LnB5OjMzMwogICAgLy8gQGFiaW1ldGhvZCgpCiAgICBiIGdldF90b3RhbF92YXVsdHNfYWZ0ZXJfaW5saW5lZF9zbWFydF9jb250cmFjdHMudHJ1c3RfdmF1bHQuY29udHJhY3QuVHJ1c3RWYXVsdC5nZXRfdG90YWxfdmF1bHRzQDQK","clear":"I3ByYWdtYSB2ZXJzaW9uIDExCiNwcmFnbWEgdHlwZXRyYWNrIGZhbHNlCgovLyBhbGdvcHkuYXJjNC5BUkM0Q29udHJhY3QuY2xlYXJfc3RhdGVfcHJvZ3JhbSgpIC0+IHVpbnQ2NDoKbWFpbjoKICAgIHB1c2hpbnQgMSAvLyAxCiAgICByZXR1cm4K"},"byteCode":{"approval":"CyAGAQAgCIDO2gOA54QPJgcGb3duZXJfBGhlaXIHbGFzdF9oYghpbnRlcnZhbAx0b3RhbF92YXVsdHMIYmFsYW5jZV8EFR98dTEbQQBmgAQwxtWKNhoAjgEATjEZFEQxGESCCQSNjKPKBP3GlcIE6ebfogRYjHMJBEiTQ10EsgW5xgS6kKtUBFUiYjsEo/x6zTYaAI4JACsAjADFAOIBDAEjAZwB5AI0ADEZIhIxGBBEQgAKMRkUMRgUEEQiQzEASSlLAmYyB0sBKk8CZisyB2YiQzYaAUkVJBJENhoCSRUlEkQXSSEED0RJIQUORDEASUsDE0QoSwFQSb1FARRESwEpTwVmSwErTwRmMgdLAipPAmYiFr8nBUxQIxa/IycEZUEACUkiCCcETGciQycEImdC//cxFiIJSTgQIhJEMQAoSwFQvUUBREsBOABLARJESwE4BzIKEkRMOAhJRCcFTwJQSb5EF08CCBa/IkM2GgFJFSQSRDEAKEsBUL1FAURJSwITRClPAmYiQzYaAUkVJRJEF0khBA9ESSEFDkQxAChLAVC9RQFESSMrY0UBRCtPAmYiQzEAKEsBUL1FAURJIypjRQFEKjIHZiJDNhoBSRUkEkQoSwFQSb1FAURLASMpY0RLAiMqY0RLAyMrY0QnBUsFUEm9RQFESb5IFzEASwUSRDIHTwQJTwMPRElEsTIKTLIITwKyB7IAIrIQI7IBs0sCKWhLAipoTwIraLxIvEgjJwRlQQALSUEAB0kiCScETGciQzYaAUkVJRJEF0lEMQAoSwFQvUUBREkjKWNFAUQnBUsBUEm9RQFESb5IF0lLBA9ESwMJFr+xMgpPArIIsgCyByKyECOyAbMiQzYaAUkVJBJEKEsBUL1FAURJIyljTE4CREkjKmNMTgJESSMrY0xOAkQnBUxQSb1FAUEAGUm+RBdLAxZLBUxQSwMWUEwWUCcGTFCwIkMjQv/nIycEZUEACUkWJwZMULAiQyNC//Q=","clear":"C4EBQw=="},"events":[],"templateVariables":{}} as unknown as Arc56Contract

/**
 * A state record containing binary data
 */
export interface BinaryState {
  /**
   * Gets the state value as a Uint8Array
   */
  asByteArray(): Uint8Array | undefined
  /**
   * Gets the state value as a string
   */
  asString(): string | undefined
}

class BinaryStateValue implements BinaryState {
  constructor(private value: Uint8Array | undefined) {}

  asByteArray(): Uint8Array | undefined {
    return this.value
  }

  asString(): string | undefined {
    return this.value !== undefined ? Buffer.from(this.value).toString('utf-8') : undefined
  }
}

/**
 * Expands types for IntelliSense so they are more human readable
 * See https://stackoverflow.com/a/69288824
 */
export type Expand<T> = T extends (...args: infer A) => infer R
  ? (...args: Expand<A>) => Expand<R>
  : T extends infer O
    ? { [K in keyof O]: O[K] }
    : never


/**
 * The argument types for the TrustVault contract
 */
export type TrustVaultArgs = {
  /**
   * The object representation of the arguments for each method
   */
  obj: {
    'opt_in()void': Record<string, never>
    'setup_vault(address,uint64)void': {
      /**
       * The trusted address (Heir) that will inherit funds after inactivity period
       */
      heir: string
      /**
       * Time in seconds before funds can be claimed (3 months to 1 year)
       */
      heartbeatInterval: bigint | number
    }
    'deposit_funds(pay)void': {
      /**
       * Payment transaction from the transaction group (must be gtxn[i] where i is the payment transaction index)
       */
      payment: AppMethodCallTransactionArgument
    }
    'update_heir(address)void': {
      /**
       * New trusted address (Heir) to inherit funds
       */
      newHeir: string
    }
    'update_heartbeat_interval(uint64)void': {
      /**
       * New heartbeat interval in seconds (3 months to 1 year)
       */
      newInterval: bigint | number
    }
    'heartbeat()void': Record<string, never>
    'claim_funds(address)void': {
      /**
       * The Vault User account whose vault funds should be claimed
       */
      vaultOwner: string
    }
    'withdraw_funds(uint64)void': {
      /**
       * Amount to withdraw from the vault
       */
      amount: bigint | number
    }
    'get_vault_info(address)(address,uint64,uint64,uint64)': {
      /**
       * The Vault User account to query vault information for
       */
      vaultOwner: string
    }
    'get_total_vaults()uint64': Record<string, never>
  }
  /**
   * The tuple representation of the arguments for each method
   */
  tuple: {
    'opt_in()void': []
    'setup_vault(address,uint64)void': [heir: string, heartbeatInterval: bigint | number]
    'deposit_funds(pay)void': [payment: AppMethodCallTransactionArgument]
    'update_heir(address)void': [newHeir: string]
    'update_heartbeat_interval(uint64)void': [newInterval: bigint | number]
    'heartbeat()void': []
    'claim_funds(address)void': [vaultOwner: string]
    'withdraw_funds(uint64)void': [amount: bigint | number]
    'get_vault_info(address)(address,uint64,uint64,uint64)': [vaultOwner: string]
    'get_total_vaults()uint64': []
  }
}

/**
 * The return type for each method
 */
export type TrustVaultReturns = {
  'opt_in()void': void
  'setup_vault(address,uint64)void': void
  'deposit_funds(pay)void': void
  'update_heir(address)void': void
  'update_heartbeat_interval(uint64)void': void
  'heartbeat()void': void
  'claim_funds(address)void': void
  'withdraw_funds(uint64)void': void
  'get_vault_info(address)(address,uint64,uint64,uint64)': [string, bigint, bigint, bigint]
  'get_total_vaults()uint64': bigint
}

/**
 * Defines the types of available calls and state of the TrustVault smart contract.
 */
export type TrustVaultTypes = {
  /**
   * Maps method signatures / names to their argument and return types.
   */
  methods:
    & Record<'opt_in()void' | 'opt_in', {
      argsObj: TrustVaultArgs['obj']['opt_in()void']
      argsTuple: TrustVaultArgs['tuple']['opt_in()void']
      returns: TrustVaultReturns['opt_in()void']
    }>
    & Record<'setup_vault(address,uint64)void' | 'setup_vault', {
      argsObj: TrustVaultArgs['obj']['setup_vault(address,uint64)void']
      argsTuple: TrustVaultArgs['tuple']['setup_vault(address,uint64)void']
      returns: TrustVaultReturns['setup_vault(address,uint64)void']
    }>
    & Record<'deposit_funds(pay)void' | 'deposit_funds', {
      argsObj: TrustVaultArgs['obj']['deposit_funds(pay)void']
      argsTuple: TrustVaultArgs['tuple']['deposit_funds(pay)void']
      returns: TrustVaultReturns['deposit_funds(pay)void']
    }>
    & Record<'update_heir(address)void' | 'update_heir', {
      argsObj: TrustVaultArgs['obj']['update_heir(address)void']
      argsTuple: TrustVaultArgs['tuple']['update_heir(address)void']
      returns: TrustVaultReturns['update_heir(address)void']
    }>
    & Record<'update_heartbeat_interval(uint64)void' | 'update_heartbeat_interval', {
      argsObj: TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void']
      argsTuple: TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']
      returns: TrustVaultReturns['update_heartbeat_interval(uint64)void']
    }>
    & Record<'heartbeat()void' | 'heartbeat', {
      argsObj: TrustVaultArgs['obj']['heartbeat()void']
      argsTuple: TrustVaultArgs['tuple']['heartbeat()void']
      returns: TrustVaultReturns['heartbeat()void']
    }>
    & Record<'claim_funds(address)void' | 'claim_funds', {
      argsObj: TrustVaultArgs['obj']['claim_funds(address)void']
      argsTuple: TrustVaultArgs['tuple']['claim_funds(address)void']
      returns: TrustVaultReturns['claim_funds(address)void']
    }>
    & Record<'withdraw_funds(uint64)void' | 'withdraw_funds', {
      argsObj: TrustVaultArgs['obj']['withdraw_funds(uint64)void']
      argsTuple: TrustVaultArgs['tuple']['withdraw_funds(uint64)void']
      returns: TrustVaultReturns['withdraw_funds(uint64)void']
    }>
    & Record<'get_vault_info(address)(address,uint64,uint64,uint64)' | 'get_vault_info', {
      argsObj: TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)']
      argsTuple: TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']
      /**
       * Tuple of (heir_address, last_heartbeat_timestamp, heartbeat_interval, vault_balance)
       */
      returns: TrustVaultReturns['get_vault_info(address)(address,uint64,uint64,uint64)']
    }>
    & Record<'get_total_vaults()uint64' | 'get_total_vaults', {
      argsObj: TrustVaultArgs['obj']['get_total_vaults()uint64']
      argsTuple: TrustVaultArgs['tuple']['get_total_vaults()uint64']
      /**
       * Total number of active vaults
       */
      returns: TrustVaultReturns['get_total_vaults()uint64']
    }>
  /**
   * Defines the shape of the state of the application.
   */
  state: {
    global: {
      keys: {
        totalVaults: bigint
      }
      maps: {}
    }
    local: {
      keys: {
        heir: string
        heartbeatInterval: bigint
        lastHeartbeat: bigint
      }
      maps: {}
    }
    box: {
      keys: {}
      maps: {
        vaultBalances: Map<string, bigint>
        vaultOwners: Map<string, bigint>
      }
    }
  }
}

/**
 * Defines the possible abi call signatures.
 */
export type TrustVaultSignatures = keyof TrustVaultTypes['methods']
/**
 * Defines the possible abi call signatures for methods that return a non-void value.
 */
export type TrustVaultNonVoidMethodSignatures = keyof TrustVaultTypes['methods'] extends infer T ? T extends keyof TrustVaultTypes['methods'] ? MethodReturn<T> extends void ? never : T  : never : never
/**
 * Defines an object containing all relevant parameters for a single call to the contract.
 */
export type CallParams<TArgs> = Expand<
  Omit<AppClientMethodCallParams, 'method' | 'args' | 'onComplete'> &
    {
      /** The args for the ABI method call, either as an ordered array or an object */
      args: Expand<TArgs>
    }
>
/**
 * Maps a method signature from the TrustVault smart contract to the method's arguments in either tuple or struct form
 */
export type MethodArgs<TSignature extends TrustVaultSignatures> = TrustVaultTypes['methods'][TSignature]['argsObj' | 'argsTuple']
/**
 * Maps a method signature from the TrustVault smart contract to the method's return type
 */
export type MethodReturn<TSignature extends TrustVaultSignatures> = TrustVaultTypes['methods'][TSignature]['returns']

/**
 * Defines the shape of the keyed global state of the application.
 */
export type GlobalKeysState = TrustVaultTypes['state']['global']['keys']

/**
 * Defines the shape of the keyed local state of the application.
 */
export type LocalKeysState = TrustVaultTypes['state']['local']['keys']

/**
 * Defines the shape of the keyed box state of the application.
 */
export type BoxKeysState = TrustVaultTypes['state']['box']['keys']


/**
 * Defines supported create method params for this smart contract
 */
export type TrustVaultCreateCallParams =
  | Expand<AppClientBareCallParams & {method?: never} & {onComplete?: OnApplicationComplete.NoOpOC} & CreateSchema>
/**
 * Defines arguments required for the deploy method.
 */
export type TrustVaultDeployParams = Expand<Omit<AppFactoryDeployParams, 'createParams' | 'updateParams' | 'deleteParams'> & {
  /**
   * Create transaction parameters to use if a create needs to be issued as part of deployment; use `method` to define ABI call (if available) or leave out for a bare call (if available)
   */
  createParams?: TrustVaultCreateCallParams
}>


/**
 * Exposes methods for constructing `AppClient` params objects for ABI calls to the TrustVault smart contract
 */
export abstract class TrustVaultParamsFactory {
  /**
   * Gets available optIn ABI call param factories
   */
  static get optIn() {
    return {
      /**
       * Constructs opt-in ABI call params for the TrustVault smart contract using the opt_in()void ABI method
       *
       * @param params Parameters for the call
       * @returns An `AppClientMethodCallParams` object for the call
       */
      optIn(params: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']>): AppClientMethodCallParams {
        return {
          ...params,
          method: 'opt_in()void' as const,
          args: Array.isArray(params.args) ? params.args : [],
        }
      },
    }
  }

  /**
   * Constructs a no op call for the setup_vault(address,uint64)void ABI method
   *
  * Set up a vault with an heir address.
  Vault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static setupVault(params: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'setup_vault(address,uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.heir, params.args.heartbeatInterval],
    }
  }
  /**
   * Constructs a no op call for the deposit_funds(pay)void ABI method
   *
  * Deposit funds into an existing vault.
  Vault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.
  Payment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static depositFunds(params: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'deposit_funds(pay)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.payment],
    }
  }
  /**
   * Constructs a no op call for the update_heir(address)void ABI method
   *
  * Update the heir address for an existing vault.
  Only the Vault User (vault owner) can update their heir.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateHeir(params: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_heir(address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newHeir],
    }
  }
  /**
   * Constructs a no op call for the update_heartbeat_interval(uint64)void ABI method
   *
  * Update the heartbeat interval for an existing vault.
  Only the Vault User can update their heartbeat interval.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static updateHeartbeatInterval(params: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'update_heartbeat_interval(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.newInterval],
    }
  }
  /**
   * Constructs a no op call for the heartbeat()void ABI method
   *
  * Update the last heartbeat timestamp to indicate Vault User activity.
  This resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static heartbeat(params: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'heartbeat()void' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
  /**
   * Constructs a no op call for the claim_funds(address)void ABI method
   *
  * Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.
  Only the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static claimFunds(params: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'claim_funds(address)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.vaultOwner],
    }
  }
  /**
   * Constructs a no op call for the withdraw_funds(uint64)void ABI method
   *
  * Allow the Vault User to withdraw funds from their vault.
  Only the Vault User (vault owner) can withdraw their funds.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static withdrawFunds(params: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'withdraw_funds(uint64)void' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.amount],
    }
  }
  /**
   * Constructs a no op call for the get_vault_info(address)(address,uint64,uint64,uint64) ABI method
   *
  * Get vault information for a Vault User.
  Can be called by anyone to query vault information.

   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getVaultInfo(params: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_vault_info(address)(address,uint64,uint64,uint64)' as const,
      args: Array.isArray(params.args) ? params.args : [params.args.vaultOwner],
    }
  }
  /**
   * Constructs a no op call for the get_total_vaults()uint64 ABI method
   *
   * Get the total number of active vaults.
   *
   * @param params Parameters for the call
   * @returns An `AppClientMethodCallParams` object for the call
   */
  static getTotalVaults(params: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']> & CallOnComplete): AppClientMethodCallParams & CallOnComplete {
    return {
      ...params,
      method: 'get_total_vaults()uint64' as const,
      args: Array.isArray(params.args) ? params.args : [],
    }
  }
}

/**
 * A factory to create and deploy one or more instance of the TrustVault smart contract and to create one or more app clients to interact with those (or other) app instances
 */
export class TrustVaultFactory {
  /**
   * The underlying `AppFactory` for when you want to have more flexibility
   */
  public readonly appFactory: _AppFactory

  /**
   * Creates a new instance of `TrustVaultFactory`
   *
   * @param params The parameters to initialise the app factory with
   */
  constructor(params: Omit<AppFactoryParams, 'appSpec'>) {
    this.appFactory = new _AppFactory({
      ...params,
      appSpec: APP_SPEC,
    })
  }
  
  /** The name of the app (from the ARC-32 / ARC-56 app spec or override). */
  public get appName() {
    return this.appFactory.appName
  }
  
  /** The ARC-56 app spec being used */
  get appSpec() {
    return APP_SPEC
  }
  
  /** A reference to the underlying `AlgorandClient` this app factory is using. */
  public get algorand(): AlgorandClient {
    return this.appFactory.algorand
  }
  
  /**
   * Returns a new `AppClient` client for an app instance of the given ID.
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public getAppClientById(params: AppFactoryAppClientParams) {
    return new TrustVaultClient(this.appFactory.getAppClientById(params))
  }
  
  /**
   * Returns a new `AppClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   *
   * Automatically populates appName, defaultSender and source maps from the factory
   * if not specified in the params.
   * @param params The parameters to create the app client
   * @returns The `AppClient`
   */
  public async getAppClientByCreatorAndName(
    params: AppFactoryResolveAppClientByCreatorAndNameParams,
  ) {
    return new TrustVaultClient(await this.appFactory.getAppClientByCreatorAndName(params))
  }

  /**
   * Idempotently deploys the TrustVault smart contract.
   *
   * @param params The arguments for the contract calls and any additional parameters for the call
   * @returns The deployment result
   */
  public async deploy(params: TrustVaultDeployParams = {}) {
    const result = await this.appFactory.deploy({
      ...params,
    })
    return { result: result.result, appClient: new TrustVaultClient(result.appClient) }
  }

  /**
   * Get parameters to create transactions (create and deploy related calls) for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TrustVault smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The params for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.params.bare.create(params)
      },
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TrustVault smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The transaction for a create call
       */
      bare: (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        return this.appFactory.createTransaction.bare.create(params)
      },
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available create methods
     */
    create: {
      /**
       * Creates a new instance of the TrustVault smart contract using a bare call.
       *
       * @param params The params for the bare (raw) call
       * @returns The create result
       */
      bare: async (params?: Expand<AppClientBareCallParams & AppClientCompilationParams & CreateSchema & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}>) => {
        const result = await this.appFactory.send.bare.create(params)
        return { result: result.result, appClient: new TrustVaultClient(result.appClient) }
      },
    },

  }

}
/**
 * A client to make calls to the TrustVault smart contract
 */
export class TrustVaultClient {
  /**
   * The underlying `AppClient` for when you want to have more flexibility
   */
  public readonly appClient: _AppClient

  /**
   * Creates a new instance of `TrustVaultClient`
   *
   * @param appClient An `AppClient` instance which has been created with the TrustVault app spec
   */
  constructor(appClient: _AppClient)
  /**
   * Creates a new instance of `TrustVaultClient`
   *
   * @param params The parameters to initialise the app client with
   */
  constructor(params: Omit<AppClientParams, 'appSpec'>)
  constructor(appClientOrParams: _AppClient | Omit<AppClientParams, 'appSpec'>) {
    this.appClient = appClientOrParams instanceof _AppClient ? appClientOrParams : new _AppClient({
      ...appClientOrParams,
      appSpec: APP_SPEC,
    })
  }
  
  /**
   * Checks for decode errors on the given return value and maps the return value to the return type for the given method
   * @returns The typed return value or undefined if there was no value
   */
  decodeReturnValue<TSignature extends TrustVaultNonVoidMethodSignatures>(method: TSignature, returnValue: ABIReturn | undefined) {
    return returnValue !== undefined ? getArc56ReturnValue<MethodReturn<TSignature>>(returnValue, this.appClient.getABIMethod(method), APP_SPEC.structs) : undefined
  }
  
  /**
   * Returns a new `TrustVaultClient` client, resolving the app by creator address and name
   * using AlgoKit app deployment semantics (i.e. looking for the app creation transaction note).
   * @param params The parameters to create the app client
   */
  public static async fromCreatorAndName(params: Omit<ResolveAppClientByCreatorAndName, 'appSpec'>): Promise<TrustVaultClient> {
    return new TrustVaultClient(await _AppClient.fromCreatorAndName({...params, appSpec: APP_SPEC}))
  }
  
  /**
   * Returns an `TrustVaultClient` instance for the current network based on
   * pre-determined network-specific app IDs specified in the ARC-56 app spec.
   *
   * If no IDs are in the app spec or the network isn't recognised, an error is thrown.
   * @param params The parameters to create the app client
   */
  static async fromNetwork(
    params: Omit<ResolveAppClientByNetwork, 'appSpec'>
  ): Promise<TrustVaultClient> {
    return new TrustVaultClient(await _AppClient.fromNetwork({...params, appSpec: APP_SPEC}))
  }
  
  /** The ID of the app instance this client is linked to. */
  public get appId() {
    return this.appClient.appId
  }
  
  /** The app address of the app instance this client is linked to. */
  public get appAddress() {
    return this.appClient.appAddress
  }
  
  /** The name of the app. */
  public get appName() {
    return this.appClient.appName
  }
  
  /** The ARC-56 app spec being used */
  public get appSpec() {
    return this.appClient.appSpec
  }
  
  /** A reference to the underlying `AlgorandClient` this app client is using. */
  public get algorand(): AlgorandClient {
    return this.appClient.algorand
  }

  /**
   * Get parameters to create transactions for the current app. A good mental model for this is that these parameters represent a deferred transaction creation.
   */
  readonly params = {
    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TrustVault smart contract using the `opt_in()void` ABI method.
       *
      * --- THIS IS THE OPT-IN METHOD ---
      Allows a user to opt-in to this contract. This creates their local state and initializes it.
      A user's wallet must send an ApplicationOptInTransaction to call this specific method.

       *
       * @param params The params for the smart contract call
       * @returns The optIn params
       */
      optIn: (params: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']> = {args: []}) => {
        return this.appClient.params.optIn(TrustVaultParamsFactory.optIn.optIn(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the TrustVault smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.params.bare.clearState(params)
    },

    /**
     * Makes a call to the TrustVault smart contract using the `setup_vault(address,uint64)void` ABI method.
     *
    * Set up a vault with an heir address.
    Vault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    setupVault: (params: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.setupVault(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `deposit_funds(pay)void` ABI method.
     *
    * Deposit funds into an existing vault.
    Vault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.
    Payment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    depositFunds: (params: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.depositFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heir(address)void` ABI method.
     *
    * Update the heir address for an existing vault.
    Only the Vault User (vault owner) can update their heir.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateHeir: (params: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.updateHeir(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heartbeat_interval(uint64)void` ABI method.
     *
    * Update the heartbeat interval for an existing vault.
    Only the Vault User can update their heartbeat interval.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    updateHeartbeatInterval: (params: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.updateHeartbeatInterval(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `heartbeat()void` ABI method.
     *
    * Update the last heartbeat timestamp to indicate Vault User activity.
    This resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    heartbeat: (params: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.heartbeat(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `claim_funds(address)void` ABI method.
     *
    * Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.
    Only the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    claimFunds: (params: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.claimFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `withdraw_funds(uint64)void` ABI method.
     *
    * Allow the Vault User to withdraw funds from their vault.
    Only the Vault User (vault owner) can withdraw their funds.

     *
     * @param params The params for the smart contract call
     * @returns The call params
     */
    withdrawFunds: (params: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.withdrawFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_vault_info(address)(address,uint64,uint64,uint64)` ABI method.
     *
    * Get vault information for a Vault User.
    Can be called by anyone to query vault information.

     *
     * @param params The params for the smart contract call
     * @returns The call params: Tuple of (heir_address, last_heartbeat_timestamp, heartbeat_interval, vault_balance)
     */
    getVaultInfo: (params: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.getVaultInfo(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_total_vaults()uint64` ABI method.
     *
     * Get the total number of active vaults.
     *
     * @param params The params for the smart contract call
     * @returns The call params: Total number of active vaults
     */
    getTotalVaults: (params: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.params.call(TrustVaultParamsFactory.getTotalVaults(params))
    },

  }

  /**
   * Create transactions for the current app
   */
  readonly createTransaction = {
    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TrustVault smart contract using the `opt_in()void` ABI method.
       *
      * --- THIS IS THE OPT-IN METHOD ---
      Allows a user to opt-in to this contract. This creates their local state and initializes it.
      A user's wallet must send an ApplicationOptInTransaction to call this specific method.

       *
       * @param params The params for the smart contract call
       * @returns The optIn transaction
       */
      optIn: (params: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']> = {args: []}) => {
        return this.appClient.createTransaction.optIn(TrustVaultParamsFactory.optIn.optIn(params))
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the TrustVault smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams>) => {
      return this.appClient.createTransaction.bare.clearState(params)
    },

    /**
     * Makes a call to the TrustVault smart contract using the `setup_vault(address,uint64)void` ABI method.
     *
    * Set up a vault with an heir address.
    Vault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    setupVault: (params: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.setupVault(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `deposit_funds(pay)void` ABI method.
     *
    * Deposit funds into an existing vault.
    Vault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.
    Payment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    depositFunds: (params: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.depositFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heir(address)void` ABI method.
     *
    * Update the heir address for an existing vault.
    Only the Vault User (vault owner) can update their heir.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateHeir: (params: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.updateHeir(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heartbeat_interval(uint64)void` ABI method.
     *
    * Update the heartbeat interval for an existing vault.
    Only the Vault User can update their heartbeat interval.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    updateHeartbeatInterval: (params: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.updateHeartbeatInterval(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `heartbeat()void` ABI method.
     *
    * Update the last heartbeat timestamp to indicate Vault User activity.
    This resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    heartbeat: (params: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.heartbeat(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `claim_funds(address)void` ABI method.
     *
    * Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.
    Only the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    claimFunds: (params: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.claimFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `withdraw_funds(uint64)void` ABI method.
     *
    * Allow the Vault User to withdraw funds from their vault.
    Only the Vault User (vault owner) can withdraw their funds.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction
     */
    withdrawFunds: (params: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.withdrawFunds(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_vault_info(address)(address,uint64,uint64,uint64)` ABI method.
     *
    * Get vault information for a Vault User.
    Can be called by anyone to query vault information.

     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Tuple of (heir_address, last_heartbeat_timestamp, heartbeat_interval, vault_balance)
     */
    getVaultInfo: (params: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.getVaultInfo(params))
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_total_vaults()uint64` ABI method.
     *
     * Get the total number of active vaults.
     *
     * @param params The params for the smart contract call
     * @returns The call transaction: Total number of active vaults
     */
    getTotalVaults: (params: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      return this.appClient.createTransaction.call(TrustVaultParamsFactory.getTotalVaults(params))
    },

  }

  /**
   * Send calls to the current app
   */
  readonly send = {
    /**
     * Gets available optIn methods
     */
    optIn: {
      /**
       * Opts the user into an existing instance of the TrustVault smart contract using the `opt_in()void` ABI method.
       *
      * --- THIS IS THE OPT-IN METHOD ---
      Allows a user to opt-in to this contract. This creates their local state and initializes it.
      A user's wallet must send an ApplicationOptInTransaction to call this specific method.

       *
       * @param params The params for the smart contract call
       * @returns The optIn result
       */
      optIn: async (params: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']> & SendParams = {args: []}) => {
        const result = await this.appClient.send.optIn(TrustVaultParamsFactory.optIn.optIn(params))
        return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['opt_in()void'])}
      },

    },

    /**
     * Makes a clear_state call to an existing instance of the TrustVault smart contract.
     *
     * @param params The params for the bare (raw) call
     * @returns The clearState result
     */
    clearState: (params?: Expand<AppClientBareCallParams & SendParams>) => {
      return this.appClient.send.bare.clearState(params)
    },

    /**
     * Makes a call to the TrustVault smart contract using the `setup_vault(address,uint64)void` ABI method.
     *
    * Set up a vault with an heir address.
    Vault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    setupVault: async (params: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.setupVault(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['setup_vault(address,uint64)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `deposit_funds(pay)void` ABI method.
     *
    * Deposit funds into an existing vault.
    Vault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.
    Payment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    depositFunds: async (params: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.depositFunds(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['deposit_funds(pay)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heir(address)void` ABI method.
     *
    * Update the heir address for an existing vault.
    Only the Vault User (vault owner) can update their heir.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateHeir: async (params: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.updateHeir(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['update_heir(address)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `update_heartbeat_interval(uint64)void` ABI method.
     *
    * Update the heartbeat interval for an existing vault.
    Only the Vault User can update their heartbeat interval.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    updateHeartbeatInterval: async (params: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.updateHeartbeatInterval(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['update_heartbeat_interval(uint64)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `heartbeat()void` ABI method.
     *
    * Update the last heartbeat timestamp to indicate Vault User activity.
    This resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    heartbeat: async (params: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.heartbeat(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['heartbeat()void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `claim_funds(address)void` ABI method.
     *
    * Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.
    Only the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    claimFunds: async (params: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.claimFunds(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['claim_funds(address)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `withdraw_funds(uint64)void` ABI method.
     *
    * Allow the Vault User to withdraw funds from their vault.
    Only the Vault User (vault owner) can withdraw their funds.

     *
     * @param params The params for the smart contract call
     * @returns The call result
     */
    withdrawFunds: async (params: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.withdrawFunds(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['withdraw_funds(uint64)void'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_vault_info(address)(address,uint64,uint64,uint64)` ABI method.
     *
    * Get vault information for a Vault User.
    Can be called by anyone to query vault information.

     *
     * @param params The params for the smart contract call
     * @returns The call result: Tuple of (heir_address, last_heartbeat_timestamp, heartbeat_interval, vault_balance)
     */
    getVaultInfo: async (params: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.getVaultInfo(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['get_vault_info(address)(address,uint64,uint64,uint64)'])}
    },

    /**
     * Makes a call to the TrustVault smart contract using the `get_total_vaults()uint64` ABI method.
     *
     * Get the total number of active vaults.
     *
     * @param params The params for the smart contract call
     * @returns The call result: Total number of active vaults
     */
    getTotalVaults: async (params: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']> & SendParams & {onComplete?: OnApplicationComplete.NoOpOC} = {args: []}) => {
      const result = await this.appClient.send.call(TrustVaultParamsFactory.getTotalVaults(params))
      return {...result, return: result.return as unknown as (undefined | TrustVaultReturns['get_total_vaults()uint64'])}
    },

  }

  /**
   * Clone this app client with different params
   *
   * @param params The params to use for the the cloned app client. Omit a param to keep the original value. Set a param to override the original value. Setting to undefined will clear the original value.
   * @returns A new app client with the altered params
   */
  public clone(params: CloneAppClientParams) {
    return new TrustVaultClient(this.appClient.clone(params))
  }

  /**
   * Methods to access state for the current TrustVault app
   */
  state = {
    /**
     * Methods to access global state for the current TrustVault app
     */
    global: {
      /**
       * Get all current keyed values from global state
       */
      getAll: async (): Promise<Partial<Expand<GlobalKeysState>>> => {
        const result = await this.appClient.state.global.getAll()
        return {
          totalVaults: result.total_vaults,
        }
      },
      /**
       * Get the current value of the total_vaults key in global state
       */
      totalVaults: async (): Promise<bigint | undefined> => { return (await this.appClient.state.global.getValue("total_vaults")) as bigint | undefined },
    },
    /**
     * Methods to access local state for the current TrustVault app
     */
    local: (address: string | Address) => {
      const encodedAddress = typeof address === 'string' ? address : encodeAddress(address.publicKey)
      return {
        /**
         * Get all current keyed values from local state
         */
        getAll: async (): Promise<Partial<Expand<LocalKeysState>>> => {
          const result = await this.appClient.state.local(encodedAddress).getAll()
          return {
            heir: result.heir,
            heartbeatInterval: result.heartbeat_interval,
            lastHeartbeat: result.last_heartbeat,
          }
        },
        /**
         * Get the current value of the heir key in local state
         */
        heir: async (): Promise<string | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("heir")) as string | undefined },
        /**
         * Get the current value of the heartbeat_interval key in local state
         */
        heartbeatInterval: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("heartbeat_interval")) as bigint | undefined },
        /**
         * Get the current value of the last_heartbeat key in local state
         */
        lastHeartbeat: async (): Promise<bigint | undefined> => { return (await this.appClient.state.local(encodedAddress).getValue("last_heartbeat")) as bigint | undefined },
      }
    },
    /**
     * Methods to access box state for the current TrustVault app
     */
    box: {
      /**
       * Get all current keyed values from box state
       */
      getAll: async (): Promise<Partial<Expand<BoxKeysState>>> => {
        const result = await this.appClient.state.box.getAll()
        return {
        }
      },
      /**
       * Get values from the vault_balances map in box state
       */
      vaultBalances: {
        /**
         * Get all current values of the vault_balances map in box state
         */
        getMap: async (): Promise<Map<string, bigint>> => { return (await this.appClient.state.box.getMap("vault_balances")) as Map<string, bigint> },
        /**
         * Get a current value of the vault_balances map by key from box state
         */
        value: async (key: string): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("vault_balances", key) as bigint | undefined },
      },
      /**
       * Get values from the vault_owners map in box state
       */
      vaultOwners: {
        /**
         * Get all current values of the vault_owners map in box state
         */
        getMap: async (): Promise<Map<string, bigint>> => { return (await this.appClient.state.box.getMap("vault_owners")) as Map<string, bigint> },
        /**
         * Get a current value of the vault_owners map by key from box state
         */
        value: async (key: string): Promise<bigint | undefined> => { return await this.appClient.state.box.getMapValue("vault_owners", key) as bigint | undefined },
      },
    },
  }

  public newGroup(): TrustVaultComposer {
    const client = this
    const composer = this.algorand.newGroup()
    let promiseChain:Promise<unknown> = Promise.resolve()
    const resultMappers: Array<undefined | ((x: ABIReturn | undefined) => any)> = []
    return {
      /**
       * Add a setup_vault(address,uint64)void method call against the TrustVault contract
       */
      setupVault(params: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.setupVault(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a deposit_funds(pay)void method call against the TrustVault contract
       */
      depositFunds(params: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.depositFunds(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a update_heir(address)void method call against the TrustVault contract
       */
      updateHeir(params: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateHeir(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a update_heartbeat_interval(uint64)void method call against the TrustVault contract
       */
      updateHeartbeatInterval(params: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.updateHeartbeatInterval(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a heartbeat()void method call against the TrustVault contract
       */
      heartbeat(params: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.heartbeat(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a claim_funds(address)void method call against the TrustVault contract
       */
      claimFunds(params: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.claimFunds(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a withdraw_funds(uint64)void method call against the TrustVault contract
       */
      withdrawFunds(params: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.withdrawFunds(params)))
        resultMappers.push(undefined)
        return this
      },
      /**
       * Add a get_vault_info(address)(address,uint64,uint64,uint64) method call against the TrustVault contract
       */
      getVaultInfo(params: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getVaultInfo(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_vault_info(address)(address,uint64,uint64,uint64)', v))
        return this
      },
      /**
       * Add a get_total_vaults()uint64 method call against the TrustVault contract
       */
      getTotalVaults(params: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']> & {onComplete?: OnApplicationComplete.NoOpOC}) {
        promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.getTotalVaults(params)))
        resultMappers.push((v) => client.decodeReturnValue('get_total_vaults()uint64', v))
        return this
      },
      get optIn() {
        return {
          optIn: (params: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']>) => {
            promiseChain = promiseChain.then(async () => composer.addAppCallMethodCall(await client.params.optIn.optIn(params)))
            resultMappers.push(undefined)
            return this
          },
        }
      },
      /**
       * Add a clear state call to the TrustVault contract
       */
      clearState(params: AppClientBareCallParams) {
        promiseChain = promiseChain.then(() => composer.addAppCall(client.params.clearState(params)))
        return this
      },
      addTransaction(txn: Transaction, signer?: TransactionSigner) {
        promiseChain = promiseChain.then(() => composer.addTransaction(txn, signer))
        return this
      },
      async composer() {
        await promiseChain
        return composer
      },
      async simulate(options?: SimulateOptions) {
        await promiseChain
        const result = await (!options ? composer.simulate() : composer.simulate(options))
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      },
      async send(params?: SendParams) {
        await promiseChain
        const result = await composer.send(params)
        return {
          ...result,
          returns: result.returns?.map((val, i) => resultMappers[i] !== undefined ? resultMappers[i]!(val) : val.returnValue)
        }
      }
    } as unknown as TrustVaultComposer
  }
}
export type TrustVaultComposer<TReturns extends [...any[]] = []> = {
  /**
   * Calls the setup_vault(address,uint64)void ABI method.
   *
  * Set up a vault with an heir address.
  Vault User must opt-in to the application first (creates local state). Initial deposit can be made via payment transaction in the same group or separately.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  setupVault(params?: CallParams<TrustVaultArgs['obj']['setup_vault(address,uint64)void'] | TrustVaultArgs['tuple']['setup_vault(address,uint64)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['setup_vault(address,uint64)void'] | undefined]>

  /**
   * Calls the deposit_funds(pay)void ABI method.
   *
  * Deposit funds into an existing vault.
  Vault User must send a payment transaction in the same transaction group. The payment must be from the vault owner to the contract address.
  Payment transaction is verified: - payment.sender == vault_owner (Txn.sender) - payment.receiver == Global.current_application_address - payment.amount > 0

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  depositFunds(params?: CallParams<TrustVaultArgs['obj']['deposit_funds(pay)void'] | TrustVaultArgs['tuple']['deposit_funds(pay)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['deposit_funds(pay)void'] | undefined]>

  /**
   * Calls the update_heir(address)void ABI method.
   *
  * Update the heir address for an existing vault.
  Only the Vault User (vault owner) can update their heir.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateHeir(params?: CallParams<TrustVaultArgs['obj']['update_heir(address)void'] | TrustVaultArgs['tuple']['update_heir(address)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['update_heir(address)void'] | undefined]>

  /**
   * Calls the update_heartbeat_interval(uint64)void ABI method.
   *
  * Update the heartbeat interval for an existing vault.
  Only the Vault User can update their heartbeat interval.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  updateHeartbeatInterval(params?: CallParams<TrustVaultArgs['obj']['update_heartbeat_interval(uint64)void'] | TrustVaultArgs['tuple']['update_heartbeat_interval(uint64)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['update_heartbeat_interval(uint64)void'] | undefined]>

  /**
   * Calls the heartbeat()void ABI method.
   *
  * Update the last heartbeat timestamp to indicate Vault User activity.
  This resets the inactivity timer and prevents funds from being transferred to the Heir. Only the Vault User can send heartbeats.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  heartbeat(params?: CallParams<TrustVaultArgs['obj']['heartbeat()void'] | TrustVaultArgs['tuple']['heartbeat()void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['heartbeat()void'] | undefined]>

  /**
   * Calls the claim_funds(address)void ABI method.
   *
  * Transfer funds to the Heir if the Vault User has been inactive beyond the heartbeat interval.
  Only the designated Heir can claim funds for a specific vault. This can be called by anyone, but only the Heir will receive the funds.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  claimFunds(params?: CallParams<TrustVaultArgs['obj']['claim_funds(address)void'] | TrustVaultArgs['tuple']['claim_funds(address)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['claim_funds(address)void'] | undefined]>

  /**
   * Calls the withdraw_funds(uint64)void ABI method.
   *
  * Allow the Vault User to withdraw funds from their vault.
  Only the Vault User (vault owner) can withdraw their funds.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  withdrawFunds(params?: CallParams<TrustVaultArgs['obj']['withdraw_funds(uint64)void'] | TrustVaultArgs['tuple']['withdraw_funds(uint64)void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['withdraw_funds(uint64)void'] | undefined]>

  /**
   * Calls the get_vault_info(address)(address,uint64,uint64,uint64) ABI method.
   *
  * Get vault information for a Vault User.
  Can be called by anyone to query vault information.

   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getVaultInfo(params?: CallParams<TrustVaultArgs['obj']['get_vault_info(address)(address,uint64,uint64,uint64)'] | TrustVaultArgs['tuple']['get_vault_info(address)(address,uint64,uint64,uint64)']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['get_vault_info(address)(address,uint64,uint64,uint64)'] | undefined]>

  /**
   * Calls the get_total_vaults()uint64 ABI method.
   *
   * Get the total number of active vaults.
   *
   * @param args The arguments for the contract call
   * @param params Any additional parameters for the call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  getTotalVaults(params?: CallParams<TrustVaultArgs['obj']['get_total_vaults()uint64'] | TrustVaultArgs['tuple']['get_total_vaults()uint64']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['get_total_vaults()uint64'] | undefined]>

  /**
   * Gets available optIn methods
   */
  readonly optIn: {
    /**
     * Opts the user into an existing instance of the TrustVault smart contract using the opt_in()void ABI method.
     *
     * @param args The arguments for the smart contract call
     * @param params Any additional parameters for the call
     * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
     */
    optIn(params?: CallParams<TrustVaultArgs['obj']['opt_in()void'] | TrustVaultArgs['tuple']['opt_in()void']>): TrustVaultComposer<[...TReturns, TrustVaultReturns['opt_in()void'] | undefined]>
  }

  /**
   * Makes a clear_state call to an existing instance of the TrustVault smart contract.
   *
   * @param args The arguments for the bare call
   * @returns The typed transaction composer so you can fluently chain multiple calls or call execute to execute all queued up transactions
   */
  clearState(params?: AppClientBareCallParams): TrustVaultComposer<[...TReturns, undefined]>

  /**
   * Adds a transaction to the composer
   *
   * @param txn A transaction to add to the transaction group
   * @param signer The optional signer to use when signing this transaction.
   */
  addTransaction(txn: Transaction, signer?: TransactionSigner): TrustVaultComposer<TReturns>
  /**
   * Returns the underlying AtomicTransactionComposer instance
   */
  composer(): Promise<TransactionComposer>
  /**
   * Simulates the transaction group and returns the result
   */
  simulate(): Promise<TrustVaultComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: SkipSignaturesSimulateOptions): Promise<TrustVaultComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  simulate(options: RawSimulateOptions): Promise<TrustVaultComposerResults<TReturns> & { simulateResponse: modelsv2.SimulateResponse }>
  /**
   * Sends the transaction group to the network and returns the results
   */
  send(params?: SendParams): Promise<TrustVaultComposerResults<TReturns>>
}
export type TrustVaultComposerResults<TReturns extends [...any[]]> = Expand<SendAtomicTransactionComposerResults & {
  returns: TReturns
}>

